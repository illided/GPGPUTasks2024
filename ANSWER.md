## Task 1

y1[n] = x[n - 1] + x[n] + x[n + 1]
y2[n] = y2[n - 2] + y2[n - 1] + x[n]

Сигнал y1 легко ложится на гпу, причем еще с coalesce access, так как не требует никакого общения между потоками. Сигнал y2 тоже можно реализовать на гпу, но придется решать систему уравнений.

## Task 2

В коде из задания 2 idx представляет собой глобальный индекс, если делать итерацию по столбцам (если считать что dim 0 == x, dim 1 == y) сверху вниз слева направо. Условие idx % 32 < 16 проверяет в какой части столбца находится поток: в верхней или нижней. 

Так как решетка 32 на 32 делится на варпы по строкам (рабочая группа делится на warp/wavefront-ы таким образом что внутри warp/wavefront номер WorkItem по оси x меняется чаще всего, затем по оси y) то все потоки в варпе находятся в одной части столбца и code divergence не произойдет

## Task 3

Заранее посчитаем что 128 / 4 = 32 элемента помещается в одной кэш линии

a) get_local_id(0) + get_local_size(0) * get_local_id(1) == глобальный индекс при перечислении решетке по строкам слева направо сверху вниз. Так как все потоки из одной строки, то запись будет coalesced и всего будет 32 кэш линии записи (32 строки)

b) get_local_id(1) + get_local_size(1) * get_local_id(0) == глобальный индекс при перечислении решетки по столбцам сверху вниз слева направо. Так как все потоки из одной строчки то запись не будет coalesced, при чем индексы так распределены, что кеш записей будет 32 * 32

c) 1 + get_local_id(0) + get_local_size(0) * get_local_id(1) == глобальный индекс при перечислении решетке по строкам слева направо сверху вниз со сдвигом на 1. Чтение будет coalesced. Так как адреса выровнены, то на каждый запрос приходится по две кэш линии (дополнительная чтобы взять последний элемент). Таким образом записей будет 2 * 32